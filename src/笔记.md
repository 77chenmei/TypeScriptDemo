# 基本类型约束

> ts 是一个可选的静态的类型系统

## 如何进行类型约束
    
> 仅需要在变量，函数的参数，函数的返回值的位置加上 ***:类型***

```typescript
let name:string;
name= 'name'

function sum (a:number,b:number):number{
    return a + b
}
sum(3,4)
```
> ts可以只能的推导出类型

```typescript
function sum (a:number,b:number){
    return a + b // 可以自动推导出函数返回值是一个number类型
}
sum(3,4)
```

> any：表示任意类型，ts不对这种类型进行类型检查

## 源代码和编译结果的差异
    
> 编译结果中的没有类型的约束信息

## 基本类型

- number：数字
- string：字符串
- blooean：布尔
- 数组
- object （不能约束到对象内部属性值的类型）
- null undefined ：
> 是所有类型的子类型，它们可以赋值给其他类型，
> 通过添加```strictNullChecks:true```，可以获得更严格的类型检查，null和undefined只能赋值给自身

## 其他类型

- 联合类型：多种类型任选其一
> 配合类型保护进行判断
> 类型保护：当对某个变量进行类型判断之后，在判断的语句中便可以确定他的确切类型，
> typeof可以出发类型保护

- void 类型
> 通常用于约束函数的返回值，表示函数没有任何返回值

- never 类型
> 通常用于约束函数的返回值，表示该函数永远不可能结束
```typescript
    function throwErr(msg:string):never{
        throw new Error(msg)
    }

    function alawys(){
        while(true){}
    }
```
- 字面量类型
> 使用一个值进行约束
```typescript
let a:'A';  // 给a赋值只能取值为A

let gender: "男"| "女"；// gender只能取值男或者女

let user :{
    name:string,
    age:number
}  // user 赋值对象中必须且只能有name和age
```
- 元祖类型（Tuple）
> 一个固定长度的数组，并且数组中的每一项确定
```typescript
let arr:[string,numner]
arr = ['2',4]
```
- any 类型
> any类型可以绕过类型检查，因此，any类型的数据可以赋值为任意类型
```typescript
let arr:any = 3 // number类型
arr = 'dsfsda' // 字符床
```

```typescript
let nums:number[];  // 定义数组必须要定义数组内每一项的类型，推荐
nums = [1,3,4]

let nums2:Array<number> = [1,2,4]  // 上面是这种写法的语法糖
```

## 类型别名
对一直的一些类型定义名称
```typescript
type 类型名称 = 。。。
```
 ```typescript
 let u:{
     name:string,
     age:number,
     gender:'男'|'女'
 }

 function getUser():{
     name:string,
     age:number,
     gender:'男'|'女'
 }[]{
     return []
 }  
 ```
> 返回一个用户数组，用以前的知识只能这样写
> 代码重复，以后想要修改，要改动的地方多

使用类型别名进行优化
```typescript
type Gender = '男'|'女'
type user = {
     name:string,
     age:number,
     gender:Gender
 }
let u:user;
 function getUser():user[]{
     return []
 }  
 ```
## 函数的相关约束
```typescript
function combine (a:number|string,b:number|string):number|string {
    if(typeof a === 'number' && typeof b === 'number'){
        return a * b
    }
    else if(typeof a === 'string' && typeof b === 'string'){
        return a + b
    }
    throw new Error('a和b 必须是相同的函数')
}

combine(3,'3')  // 这样传入数据会报错
```
> 类型会缺失：number|string类型
> 参数都是number，返回值只能是number，但现在不满足条件

***函数重载***：在函数实现之前，对函数调用多种情况进行申明
```typescript
/
function combine(a:number,b:number):number;
function combine(a:string,b:string):string'

function combine (a:number|string,b:number|string):number|string {
    if(typeof a === 'number' && typeof b === 'number'){
        return a * b
    }
    else if(typeof a === 'string' && typeof b === 'string'){
        return a + b
    }
    throw new Error('a和b 必须是相同的函数')
}
```
***可选参数***：可以在某些参数名后加上`？`表示该参数可以不用传递
```typescript
// 想要将参数相加，可以传两个或者三个
function sum (a:number,b:number,c?:number){
    if(c) return a+b+c
    return a+b
}
sum(3,4)
sum(3,4,5)
```
***默认参数***：定是可选参数，一定不是undefined类型
```typescript
function sum (a:number,b:number,c:number = 0){
    if(c) return a+b+c
    return a+b
}
sum(3,4)
sum(3,4,5)
```

## 补充说明

    > 更改函数名：选中函数名，按```F2```,重新写函数名

## 扑克牌小练习

目标：创建一副扑克牌（不包括大小王），打印扑克牌


分支:
git checkout  practice-poker