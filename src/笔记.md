# 基本类型约束

> ts 是一个可选的静态的类型系统

## 如何进行类型约束
    
> 仅需要在变量，函数的参数，函数的返回值的位置加上 ***:类型***

```typescript
let name:string;
name= 'name'

function sum (a:number,b:number):number{
    return a + b
}
sum(3,4)
```
> ts可以只能的推导出类型

```typescript
function sum (a:number,b:number){
    return a + b // 可以自动推导出函数返回值是一个number类型
}
sum(3,4)
```

> any：表示任意类型，ts不对这种类型进行类型检查

## 源代码和编译结果的差异
    
> 编译结果中的没有类型的约束信息

## 基本类型

- number：数字
- string：字符串
- blooean：布尔
- 数组
- object （不能约束到对象内部属性值的类型）
- null undefined ：
> 是所有类型的子类型，它们可以赋值给其他类型，
> 通过添加```strictNullChecks:true```，可以获得更严格的类型检查，null和undefined只能赋值给自身

## 其他类型

- 联合类型：多种类型任选其一
> 配合类型保护进行判断
> 类型保护：当对某个变量进行类型判断之后，在判断的语句中便可以确定他的确切类型，
> typeof可以出发类型保护

- void 类型
> 通常用于约束函数的返回值，表示函数没有任何返回值

- never 类型
> 通常用于约束函数的返回值，表示该函数永远不可能结束
```typescript
    function throwErr(msg:string):never{
        throw new Error(msg)
    }

    function alawys(){
        while(true){}
    }
```
- 字面量类型
> 使用一个值进行约束
```typescript
let a:'A';  // 给a赋值只能取值为A

let gender: "男"| "女"；// gender只能取值男或者女

let user :{
    name:string,
    age:number
}  // user 赋值对象中必须且只能有name和age
```
- 元祖类型（Tuple）


- any 类型

```typescript
let nums:number[];  // 定义数组必须要定义数组内每一项的类型，推荐
nums = [1,3,4]

let nums2:Array<number> = [1,2,4]  // 上面是这种写法的语法糖
```
# 补充说明

    > 更改函数名：选中函数名，按```F2```,重新写函数名

# 扑克牌小练习

目标：创建一副扑克牌（不包括大小王），打印扑克牌


分支:
git checkout  practice-poker